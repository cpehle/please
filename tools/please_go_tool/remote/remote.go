// Package remote implements a helper for 'go get' to facilitate breaking it up
// into separate plz targets.
package remote

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os/exec"
	"path"
	"sort"
	"strings"
	"sync"

	"gopkg.in/op/go-logging.v1"
)

var log = logging.MustGetLogger("remote")

const template = `
go_remote_library(
    name = '%s',
    url = '%s',
    deps = [
        '%s',
    ],
)
`

// FetchLibraries uses 'go get' to fetch a series of libraries, and generate either a sequence of
// build rules describing them or a pithy description of them which can be parsed back
// into BUILD rules later. The BUILD rules generated by the former re-invoke this using the latter
// format to determine what exactly to build and how.
func FetchLibraries(gotool string, shortFormat bool, packages ...string) (string, error) {
	if out, err := goCommand(gotool, "get", "-d", packages...); err != nil {
		return "", fmt.Errorf("%s: %s", err, string(out))
	}
	packageData, err := goList(gotool, packages...)
	if err != nil {
		return "", err
	}
	// This gives us all their dependencies. go get might have fetched some others that we
	// don't know about, so we ask go list to re-describe them all to work out which are
	// system or not.
	packageData, err = goList(gotool, packageData.UniqueDeps()...)
	if err != nil {
		return "", err
	}
	// Now build up the response.
	var buf bytes.Buffer
	m := packageData.ToMap()
	for _, pkg := range packageData {
		if !pkg.Standard {
			if shortFormat {
				buf.WriteString(pkg.ToShortFormatString(m))
			} else {
				buf.WriteString(pkg.ToBuildRule(m))
			}
		}
	}
	return buf.String(), nil
}

// goCommand runs a Go command and returns its output.
func goCommand(gotool string, command, flag string, packages ...string) ([]byte, error) {
	if !strings.HasPrefix(gotool, "/") {
		path, err := exec.LookPath(gotool)
		if err != nil {
			return nil, err
		}
		gotool = path
	}
	log.Notice("Running %s %s %s %s...", gotool, command, flag, strings.Join(packages, " "))
	args := append([]string{command, flag}, packages...)
	cmd := exec.Command(gotool, args...)
	return cmd.Output()
}

// goList runs "go list -json" on the given packages and parses it to a struct.
func goList(gotool string, packages ...string) (jsonPackages, error) {
	out, err := goCommand(gotool, "list", "-json", packages...)
	if err != nil {
		return nil, fmt.Errorf("%s: %s", err, string(out))
	}
	packageData := jsonPackages{}
	return packageData, packageData.FromJSON(out)
}

// A jsonPackage is a minimal copy of go list's builtin struct definition.
// Note that we don't support every possible feature here, only those that map to Please.
type jsonPackage struct {
	Dir          string // N.B. absolute path.
	Root         string
	ImportPath   string
	Target       string
	Standard     bool
	GoFiles      []string
	CgoFiles     []string
	CFiles       []string
	HFiles       []string
	CgoCFLAGS    []string
	CgoLDFLAGS   []string
	CgoPkgConfig []string // TODO(pebers): add support for this to cgo_library
	Imports      []string
	Deps         []string

	// GitURL is not in the upstream structure. We annotate it ourselves later.
	GitURL string
}

// ToShortFormatString returns a short delimited string format that Please will re-parse later
// to create a build rule from.
func (jp jsonPackage) ToShortFormatString(packages map[string]jsonPackage) string {
	comma := func(s []string) string { return strings.Join(s, ",") }
	caret := func(s []string) string { return strings.Join(s, "^") }

	name := strings.Replace(jp.ImportPath, "/", "_", -1)
	dir := jp.trimRoot(jp.Dir)
	gofiles := comma(jp.GoFiles)
	deps := comma(jp.deps(packages))
	if len(jp.CgoFiles) == 0 {
		return fmt.Sprintf("%s|%s|%s|%s\n", name, dir, gofiles, deps)
	}
	// Cgo packages need quite a bit more information.
	cgofiles := comma(jp.CgoFiles)
	cfiles := comma(jp.CFiles)
	hfiles := comma(jp.HFiles)
	cflags := caret(jp.CgoCFLAGS)
	ldflags := caret(jp.CgoLDFLAGS)
	return fmt.Sprintf("%s|%s|%s|%s|%s|%s|%s|%s|%s\n", name, dir, gofiles, cgofiles, cfiles, hfiles, cflags, ldflags, deps)
}

// ToBuildRule returns a build rule representation suitable for copying into a BUILD file.
func (jp jsonPackage) ToBuildRule(packages map[string]jsonPackage) string {
	name := strings.Replace(jp.ImportPath, "/", "_", -1)
	deps := jp.deps(packages)
	return fmt.Sprintf(template, name, jp.GitURL, strings.Join(deps, "',\n        '"))
}

// trimRoot strips the root from the given string.
func (jp jsonPackage) trimRoot(s string) string {
	return strings.TrimLeft(strings.TrimPrefix(s, jp.Root), "/")
}

// paths updates a sequence of paths with the given prefix.
func (jp jsonPackage) paths(dir string, ps []string) []string {
	for i, p := range ps {
		ps[i] = path.Join(dir, p)
	}
	return ps
}

// deps returns the non-system dependencies for this package.
func (jp jsonPackage) deps(packages map[string]jsonPackage) []string {
	ret := make([]string, 0, len(jp.Imports))
	for _, imp := range jp.Imports {
		if pkg, present := packages[imp]; present && !pkg.Standard {
			ret = append(ret, strings.Replace(imp, "/", "_", -1))
		}
	}
	return ret
}

// FindGitURL finds the upstream Git URL of this package.
func (jp jsonPackage) FindGitURL() (string, error) {
	cmd := exec.Command("git", "config", "--get", "remote.origin.url")
	cmd.Dir = jp.Dir
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	// Strip https:// prefix for more natural Go paths. We can assume it again later.
	return strings.TrimPrefix("https://", string(out)), nil
}

type jsonPackages []jsonPackage

// UniqueDeps returns the unique set of deps from a set of packages.
func (jps jsonPackages) UniqueDeps() []string {
	m := map[string]struct{}{}
	for _, jp := range jps {
		for _, dep := range jp.Deps {
			m[dep] = struct{}{}
		}
	}
	ret := make([]string, 0, len(m))
	for pkg := range m {
		ret = append(ret, pkg)
	}
	sort.Strings(ret)
	return ret
}

// ToMap converts the jsonPackages slice to a map of package import path -> package.
func (jps jsonPackages) ToMap() map[string]jsonPackage {
	m := make(map[string]jsonPackage, len(jps))
	for _, jp := range jps {
		m[jp.ImportPath] = jp
	}
	return m
}

// AnnotateGitURLs attempts to find the Git URL for each package.
func (jps jsonPackages) AnnotateGitURLs() error {
	var err error
	var wg sync.WaitGroup
	wg.Add(len(jps))
	for i, jp := range jps {
		go func(i int, jp jsonPackage) {
			url, e := jp.FindGitURL()
			if e != nil {
				err = e
			} else {
				jps[i].GitURL = url
			}
			wg.Done()
		}(i, jp)
	}
	wg.Wait()
	return err
}

// FromJSON loads this set of packages from JSON.
// This is not as easy as you'd think since the output for multiple packages is not valid JSON -
// it's a sequence of top-level JSON objects one after another.
func (jps *jsonPackages) FromJSON(data []byte) error {
	d := append([]byte{'['}, bytes.Replace(data, []byte("}\n{"), []byte("},{"), -1)...)
	d = append(d, ']')
	return json.Unmarshal(d, jps)
}
